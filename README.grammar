Grammar for cicada:

string-to-string rules (aka Hiero rules):

[lhs] ||| [x,1] abc bb ||| ddd [x,1] ||| feature=1.0 feature2=5.6 ||| attr1=1.6
[lhs] ||| [x,1] abc [x,2] bb ||| ddd [x,1] fff [x,2] ||| feature=-1 feature2=8 ||| attr2="bad"

cicada assume that rule's non-terminal indices are sorted wrt the source side, not target side.

tree-to-string/string-to-tree transduction rules:

[LHS]([NN,1](terminal [NP](xxx) [NP,2])) ||| [LHS]([VP](yyy [x,2] zzz) [x,1]) ||| feature=6.8 ||| attr2="attribute 2"

In cicada, various file-based gramamr can be loaded in addition to pre-defined glue-rules, by

	--grammar file-name:max-span="maximum-span",feature0="name-of-first-feature", feature1="name-of-second-feature", ...
	--grammar glue:straight=ture,inverted=true,non-terminal=[x],goal=[s],fallback=<fallback non-terminal symbol list>
	--grammar insertion:non-terminal=[x]
	--grammar deletion:non-terminal=[x]
	--grammar pos
	--grammar pair:non-terminal=[x]
	--grammar unknown:signature=English,file=[grammar spec],character=[character model]

For detail see --grammar-list
