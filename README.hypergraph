
The hypergraph format is a-bit complicated, and most people will not want to
edit by yourself (including me).
A convenience tool exists, 

cicada_filter_penntreebank and cicada_filter_dependency

to convert from penn-treebank or dependency structures into hypergraph format.

PennTreebank filter was tested on output from stanford parser, thus, may not work on raw treebank file.
If you need support contact me.

cicada_filter_penntreebank [options]
options:
  --input arg (=-)      input file
  --output arg (=-)     output
  --map arg             map terminal symbols
  --escape              escape English penntreebank
  --normalize           normalize category, such as [,] [.] etc.
  --leaf                collect leaf nodes only
  --rule                collect rules only
  --span                collect span only
  --binarize            perform binarization
  --category            added category to span
  --unary-top           use top-most category for unary rules
  --unary-bottom        use bottom-most category for unary rules
  --unary-root          use single category for root
  --exclude-terminal    no terminal in span
  --debug [=arg(=1)]    debug level
  --help                help message

For English treebanks, you may want to transform [,] or [.] into [COMMA] [PERIOD] respectively, otherwise
you may encounter serious errors. (',' is a separator for index and category!)
If your parser automatically modify tokens (like '(' => -LRB- etc.), you can use --map <file name>
which will map the modified terminals into the original form, where "file name" is your original data
used as an input to your parser.
"--span" option will print spans each category covers. together with --category, you can dump span in
first-last:category.

For forest output, we can use Charniak parser exteded with forest output or 
Egret parser, another parser variant supporting English/Chinese.

cicada_filter_charniak [options]
options:
  --input arg (=-)      input file
  --output arg (=-)     output
  --map arg             map terminal symbols
  --normalize           normalize category, such as [,] [.] etc.
  --debug [=arg(=1)]    debug level
  --help                help message

Dependency outputs are transformed by cicada_filter_dependency with --hypergraph option.
Head words are split into different hyperedge (--head) or incorporated into an existing edge (default).
The input is either MST (--mst), CoNLL (--conll) or Cabocha (--cabocha), and by default w/o --hypergraph option, 
the tool output dependency information in a single line:

sentence ||| POSs ||| dependency

where POSs is a sequence of either POS (by default) or dependency relation (--relation).
The tool (will) supports projection of source-side dependency into target-side via word alignment (TODO!).

cicada_filter_dependency [options]
options:
  --input arg               input file(s)
  --output arg (="-")       output file
  --source arg              source file(s)
  --target arg              target file(s)
  --alignment arg           alignment file(s)
  --dependency arg          dependency file(s)
  --list arg                list file
  --list-source arg         source list file
  --list-target arg         target list file
  --list-alignment arg      alignment list file
  --list-dependency arg     dependency list file
  --goal arg (=[s])         goal symbol
  --non-terminal arg (=[x]) non-terminal symbol
  --bilingual               project source dependency into target dependency
  --mst                     tranform MST dependency
  --conll                   tranform CoNLL dependency
  --cabocha                 tranform Cabocha dependency
  --forest                  tranform FOREST dependency
  --projective              project into projective dependency
  --relation                assing relation to POS
  --hypergraph              output as a hypergraph
  --head                    output hypergraph with explicit head
  --help                    help message

You can merge multiple hypergraphs in one by:
cicada_unite_forest
	This will simply merge by root...

FORMAT of HYPEERGRAPH

The hypergraph is represented by JSON data format (www.json.org)
Strings must be escaped (see JSON specification). You may insert spaces at arbitrary positions.
One-line-per-single-hypergraph is prefered for easier preprocessing.
We assume topologically sorted hypergraph (or, node-id is ordered by post-traversal order), but
input/output can handle any-ordered hypergraph.

HYPERGRAPH

{
 "rules" : [ RULE, RULE, ... ], (RULE position (one-based) is the rule-id inside this hypergraph. zero is reserved for no-rule (error?))
 "nodes" : [ NODE, NODE, ...],  (NODE positin (zero-based) is the node-id inside this hypergraph)
 "goal" : node-id-for-goal (usually pointing to the last-node. No goal implies an invalid graph)
}

RULE (rules are double quoted, thus you should perform proper escaping, i.e. " to \", \ to \\ etc.)

"lhs ||| rhs"

NODE (contains list of edge)

[EDGE, EDGE, ...]

EDGE

{
 "tail" : [node-id, node-id, ...],  (if no tails, this entry is empty)
 "feature" : {"feature-name" : double, "feature-name2" : double, ... }, (if no features, this entry is empty)
 "attribute" : {"attribute-name" : ATTRIBUTE, "attribute-name2" : ATTRIBUTE, ...}, (if no attributes, this entry is empty)
 "rule" : rule-id (zero indicating no-rule == invalid hypergraph)
}

ATTRIBUTE

float(double precision) | integer(64-bit) | " escaped string "

